/* 
 * Copyright (c) 2014 RobotsByTheC. All rights reserved.
 *
 * Open Source Software - may be modified and shared by FRC teams. The code must
 * be accompanied by the BSD license file in the root directory of the project.
 */
package org.usfirst.frc2084.CMonster2015;

import org.usfirst.frc2084.CMonster2015.commands.FrontAutonomousCommandGroup;
import org.usfirst.frc2084.CMonster2015.commands.FunCommand;
import org.usfirst.frc2084.CMonster2015.subsystems.CatcherSubsystem;
import org.usfirst.frc2084.CMonster2015.subsystems.DriveSubsystem;
import org.usfirst.frc2084.CMonster2015.subsystems.LedSubsystem;
import org.usfirst.frc2084.CMonster2015.subsystems.SweeperSubsystem;

import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the IterativeRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */
public class Robot extends IterativeRobot {
	private Command autonomousCommand;
	private Command funCommand;
	private final SendableChooser autonomousChooser = new SendableChooser();
	public static OI oi;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	public static DriveSubsystem driveSubsystem;
	public static SweeperSubsystem sweeperSubsystem;
	public static CatcherSubsystem catcherSubsystem;
	public static LedSubsystem ledSubsystem;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	/**
	 * This function is run when the robot is first started up and should be
	 * used for any initialization code.
	 */
	@Override
	public void robotInit() {
		RobotMap.init();
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
		driveSubsystem = new DriveSubsystem();
		sweeperSubsystem = new SweeperSubsystem();
		catcherSubsystem = new CatcherSubsystem();
		ledSubsystem = new LedSubsystem();
		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
		oi = new OI();
		// instantiate the command used for the autonomous period
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
		funCommand = new FunCommand();
		funCommand.start();
		autonomousChooser.addDefault("Front Left Goal", new FrontAutonomousCommandGroup(true));
		autonomousChooser.addObject("Front Right Goal", new FrontAutonomousCommandGroup(false));
		SmartDashboard.putData("Autonomous Mode", autonomousChooser);
		// Make sure the DS laptop is not reporting vision to the robot
		TargetTrackingCommunication.setAutonomousVisionRunning(false);
		// Enable the camera on the DS laptop when the robot starts
		TargetTrackingCommunication.setCameraEnabled(true);
	}

	@Override
	public void autonomousInit() {
		// // Last ditch effort to bring the camera up on the DS laptop,
		// probably
		// // is too late.
		// TargetTrackingCommunication.setCameraEnabled(true);
		// // Tell the DS laptop to starting detecting the hot target
		// TargetTrackingCommunication.setAutonomousVisionRunning(true);
		// Pick which autonomous mode to use.
		Object selection = autonomousChooser.getSelected();
		if (selection != null && selection instanceof Command) {
			autonomousCommand = (Command) selection;
			autonomousCommand.start();
		} else {
			System.out.println("No autonomous mode selected.");
		}
	}

	/**
	 * This function is called periodically during autonomous
	 */
	@Override
	public void autonomousPeriodic() {
		Scheduler.getInstance().run();
	}

	@Override
	public void teleopInit() {
		TargetTrackingCommunication.setAutonomousVisionRunning(false);
		TargetTrackingCommunication.setCameraEnabled(false);
		// This makes sure that the autonomous stops running when
		// teleop starts running. If you want the autonomous to
		// continue until interrupted by another command, remove
		// this line or comment it out.
		if (autonomousCommand != null) {
			autonomousCommand.cancel();
		}
		Robot.driveSubsystem.getMecanumDriveAlgorithm().resetGyro();
	}

	/**
	 * This function is called periodically during operator control
	 */
	@Override
	public void teleopPeriodic() {
		Scheduler.getInstance().run();
	}

	/**
	 * This function called periodically during test mode
	 */
	@Override
	public void testPeriodic() {
		LiveWindow.run();
	}

	@Override
	public void disabledInit() {
	}

	@Override
	public void disabledPeriodic() {
		Scheduler.getInstance().run();
	}
}
