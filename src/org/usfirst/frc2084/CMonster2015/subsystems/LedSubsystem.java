/* 
 * Copyright (c) 2014 RobotsByTheC. All rights reserved.
 *
 * Open Source Software - may be modified and shared by FRC teams. The code must
 * be accompanied by the BSD license file in the root directory of the project.
 */
package org.usfirst.frc2084.CMonster2015.subsystems;

import org.usfirst.frc2084.CMonster2015.Robot;
import org.usfirst.frc2084.CMonster2015.RobotMap;

import edu.wpi.first.wpilibj.DigitalOutput;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.command.Subsystem;

/**
 * The subsystem that communicates with the Arduino to control the LED strip. It
 * uses six DIO pins to form a six bit number. Each number codes for a different
 * led pattern.
 */
public class LedSubsystem extends Subsystem {
	// Values that are added to the codes to create a specific color.
	private static final int RED_OFFSET = 0;
	private static final int BLUE_OFFSET = 1;
	private static final int GREEN_OFFSET = 2;
	// LED strip pattern definitions
	public static final int DISABLE_CODE = 0x3F;
	public static final int SOLID_CODE = 0x0;
	public static final int BLINK_CODE = 0x3;
	public static final int PULSE_CODE = 0x6;
	public static final int CONVERGE_CODE = 0x9;
	public static final int DIVERGE_CODE = 0xC;
	public static final int RANDOM_PATTERN_CODE = 0xF;
	/**
	 * Stores the current pattern code the LEDs are displaying. This does not
	 * include the color offset.
	 */
	private int pattern = DISABLE_CODE;
	/**
	 * The color offset for the code. This only applies to codes that can appear
	 * in multiple colors.
	 */
	private int offset = GREEN_OFFSET;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	DigitalOutput pin0 = RobotMap.ledSubsystemPin0;
	DigitalOutput pin1 = RobotMap.ledSubsystemPin1;
	DigitalOutput pin2 = RobotMap.ledSubsystemPin2;
	DigitalOutput pin3 = RobotMap.ledSubsystemPin3;
	DigitalOutput pin4 = RobotMap.ledSubsystemPin4;
	DigitalOutput pin5 = RobotMap.ledSubsystemPin5;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	@Override
	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	}

	/**
	 * Updates the pattern that the LEDs are displaying. This method checks the
	 * status of various robot components to determine what pattern to display.
	 */
	public void updatePattern() {
		int oldPattern = pattern;
		int oldOffset = offset;
		// LEDs are solid by default
		pattern = SOLID_CODE;
		DriverStation ds = DriverStation.getInstance();
		if (ds.isEnabled()) {
			// Enabled
			if (ds.isAutonomous()) {
				// Autonomous mode
				pattern = RANDOM_PATTERN_CODE;
			} else if (ds.isOperatorControl()) {
				// Teleop
				if (Robot.catcherSubsystem.isExtended()) {
					// Catcher extended
					pattern = BLINK_CODE;
				} else {
					switch (Robot.sweeperSubsystem.getState().state) {
					case SweeperSubsystem.MotorState.SWEEPING_VALUE:
						// Sweeper sweeping
						pattern = DIVERGE_CODE;
						break;
					case SweeperSubsystem.MotorState.EJECTING_VALUE:
						// Sweeper ejecting
						pattern = CONVERGE_CODE;
						break;
					default:
					case SweeperSubsystem.MotorState.OFF_VALUE:
						// Sweeper off
						if (Robot.sweeperSubsystem.isExtended()) {
							// Sweeper extended
							pattern = PULSE_CODE;
						}
						break;
					}
				}
			}
		}
		// Update the color offset based on the current alliance.
		switch (DriverStation.getInstance().getAlliance()) {
		case Red:
			offset = RED_OFFSET;
			break;
		case Blue:
			offset = BLUE_OFFSET;
			break;
		default:
		case Invalid:
			// If the alliance is unknown (ie. not connected to FMS), make
			// the LEDs green.
			offset = GREEN_OFFSET;
			break;
		}
		// If the pattern or offset has changed, send the new data to the
		// Arduino.
		if (oldPattern != pattern || oldOffset != offset) {
			switch (pattern) {
			// DISABLE_CODE and RANDOM_PATTERN_CODE do not have different
			// colors, so do not factor in the offset.
			case DISABLE_CODE:
			case RANDOM_PATTERN_CODE:
				sendData(pattern);
				break;
			default:
				// Every other code is available in red, blue or green.
				sendData(pattern + offset);
			}
		}
	}

	/**
	 * Sends the specified code to the DIO pins and to the Arduino.
	 *
	 * @param code the code to send
	 */
	private void sendData(int code) {
		// The mask initially starts at one to get the value of the first bit
		// the first time the loop runs.
		byte mask = 0x1;
		// Loops through the first six bits in the code and sets the apporiate
		// DIO to its value.
		for (int i = 0; i < 6; i++) {
			DigitalOutput out;
			switch (i) {
			case 0:
				out = pin0;
				break;
			case 1:
				out = pin1;
				break;
			case 2:
				out = pin2;
				break;
			case 3:
				out = pin3;
				break;
			case 4:
				out = pin4;
				break;
			case 5:
			default:
				out = pin5;
			}
			// This concise one-liner isolates the bit specified by the bitmask
			// and checks if it is equal to one. This boolean value turns the
			// DIO pin on or off.
			out.set((code & mask) == mask);
			// Shift the mask left one bit so it will get the next bit the next
			// time the loop runs.
			mask <<= 1;
		}
	}
}
