/* 
 * Copyright (c) 2015 RobotsByTheC. All rights reserved.
 *
 * Open Source Software - may be modified and shared by FRC teams. The code must
 * be accompanied by the BSD license file in the root directory of the project.
 */
package org.usfirst.frc.team2084.CMonster2015.subsystems;

import org.usfirst.frc.team2084.CMonster2015.Robot;
import org.usfirst.frc.team2084.CMonster2015.RobotMap;

import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.DoubleSolenoid;
import edu.wpi.first.wpilibj.DoubleSolenoid.Value;
import edu.wpi.first.wpilibj.MotorSafety;
import edu.wpi.first.wpilibj.MotorSafetyHelper;
import edu.wpi.first.wpilibj.Solenoid;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.Subsystem;

/**
 * The subsystem that controls the tote lifter (and its regenerative air
 * system), the gate and the ejector.
 */
public class ToteLifterSubsystem extends Subsystem {

    public static final int EJECTOR_TALON_PDP_CHANNEL = 15;
    public static final double EJECTOR_TALON_EXTENED_CURRENT_THRESHOLD = 15;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    Solenoid raiseSolenoid = RobotMap.toteLifterSubsystemRaiseSolenoid;
    DoubleSolenoid storageSolenoid = RobotMap.toteLifterSubsystemStorageSolenoid;
    Solenoid lowerVentSolenoid = RobotMap.toteLifterSubsystemLowerVentSolenoid;
    Solenoid gateSolenoid = RobotMap.toteLifterSubsystemGateSolenoid;
    DigitalInput ejectorExtendedLimitSwitch = RobotMap.toteLifterSubsystemEjectorExtendedLimitSwitch;
    DigitalInput ejectorRetractedLimitSwitch = RobotMap.toteLifterSubsystemEjectorRetractedLimitSwitch;
    SpeedController ejectorTalon = RobotMap.toteLifterSubsystemEjectorTalon;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    private final MotorSafetyHelper watchdog = new MotorSafetyHelper((MotorSafety) ejectorTalon);

    public enum LifterState {
        FIRST_RAISE(true, Value.kReverse, false),
        RAISE(true, Value.kReverse, true),
        STORE(false, Value.kForward, false),
        LOWER(false, Value.kReverse, false);

        private final boolean raise;
        private final Value storage;
        private final boolean lowerVent;

        private LifterState(boolean raise, Value storage, boolean lowerVent) {
            this.raise = raise;
            this.storage = storage;
            this.lowerVent = lowerVent;
        }
    }

    private LifterState lifterState = LifterState.STORE;

    public void setLifterState(LifterState state) {
        lifterState = state;
        raiseSolenoid.set(state.raise);
        storageSolenoid.set(state.storage);
        lowerVentSolenoid.set(state.lowerVent);
    }

    public LifterState getLifterState() {
        return lifterState;
    }

    public enum GateState {
        OPEN(false),
        CLOSED(true);

        private final boolean value;

        private GateState(boolean value) {
            this.value = value;
        }
    }

    private GateState gateState = GateState.OPEN;

    public void setGateState(GateState state) {
        gateState = state;
        gateSolenoid.set(state.value);
    }

    public GateState getGateState() {
        return gateState;
    }

    public enum EjectorState {
        EXTENDING(-0.3),
        RETRACTING(0.3),
        STOPPED(0.0);

        private final double speed;

        private EjectorState(double speed) {
            this.speed = speed;
        }
    }

    private EjectorState ejectorState = EjectorState.STOPPED;

    public void setEjectorState(EjectorState state) {
        ejectorState = state;

        watchdog.setSafetyEnabled(state != EjectorState.STOPPED);
        ejectorTalon.set(state.speed);
    }

    public EjectorState getEjectorState() {
        return ejectorState;
    }

    public boolean isEjectorExtended() {
        return Robot.pdp.getCurrent(EJECTOR_TALON_PDP_CHANNEL) > EJECTOR_TALON_EXTENED_CURRENT_THRESHOLD;
        // return ejectorExtendedLimitSwitch.get();
    }

    public boolean isEjectorRetracted() {
        return false; // ejectorRetractedLimitSwitch.get();
    }

    @Override
    public void initDefaultCommand() {

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    }
}
