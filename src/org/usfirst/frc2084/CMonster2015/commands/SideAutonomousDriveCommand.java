/* 
 * Copyright (c) 2014 RobotsByTheC. All rights reserved.
 *
 * Open Source Software - may be modified and shared by FRC teams. The code must
 * be accompanied by the BSD license file in the root directory of the project.
 */
package org.usfirst.frc2084.CMonster2015.commands;

import org.usfirst.frc2084.CMonster2015.Robot;
import org.usfirst.frc2084.CMonster2015.RobotMap;
import edu.wpi.first.wpilibj.ADXL345_I2C;
import edu.wpi.first.wpilibj.command.Command;

/**
 * DOES NOT WORK! DO NOT USE!
 */
public class SideAutonomousDriveCommand extends Command {
	/**
	 * The speed to drive at for the first part of autonomous. The robot should
	 * continue at this speed until it has reached {@link #FAST_DRIVE_DISTANCE}.
	 */
	private static final double FAST_DRIVING_SPEED = 0.9;
	/**
	 * The speed to drive for hitting the wall and turning.
	 */
	private static final double SLOW_DRIVING_SPEED = 0.9;
	/**
	 * The distance to drive while moving at {@link #FAST_DRIVING_SPEED} in
	 * feet.
	 */
	private static final double FAST_DRIVE_DISTANCE = 3.0;
	/**
	 * The rate at which the robot should accelerate.
	 */
	private static final double ACCELERATION = 1.1;
	/**
	 * The G-Force threshold at which the robot should stop. This needs to be
	 * calibrated.
	 */
	private static final double GFORCE_LIMIT = 0.7;
	/**
	 * The orientation the robot should be in when it hits the wall in degrees.
	 */
	private static final double ROTATION_SETPOINT = 90.0;
	/**
	 * Maximum time this part of autonomous can take before ending
	 * automatically. This is to prevent a major problem should the robot not
	 * detect when it hits the wall.
	 */
	private static final double TIMEOUT = 4.0;
	private double gForce = 0.0;
	private double currentSpeed = 0.0;
	private double currentAngle = 0.0;
	private boolean movingFast = true;
	private final boolean leftGoal;

	public SideAutonomousDriveCommand(boolean leftGoal) {
		super(TIMEOUT);
		this.leftGoal = leftGoal;
		// Use requires() here to declare subsystem dependencies
		// eg. requires(chassis);
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
		requires(Robot.driveSubsystem);
		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	}

	/**
	 * Called just before this {@link Command} runs the first time.
	 */
	@Override
	protected void initialize() {
		currentAngle = 0.0;
		currentSpeed = 0.0;
		movingFast = true;
		RobotMap.driveSubsystemRearRightEncoder.reset();
	}

	/**
	 * Called repeatedly when this {@link Command} is scheduled to run.
	 */
	@Override
	protected void execute() {
		gForce = RobotMap.driveSubsystemAccelerometer.getAcceleration(ADXL345_I2C.Axes.kY);
		double distance = RobotMap.driveSubsystemRearRightEncoder.getDistance();
		if (movingFast) {
			if (distance < FAST_DRIVE_DISTANCE) {
				if (currentSpeed < FAST_DRIVING_SPEED) {
					currentSpeed = timeSinceInitialized() * ACCELERATION;
				}
			} else {
				movingFast = false;
				currentSpeed = SLOW_DRIVING_SPEED;
				currentAngle = leftGoal ? -ROTATION_SETPOINT : ROTATION_SETPOINT;
			}
		}
		Robot.driveSubsystem.getMecanumDriveAlgorithm().driveFieldOrientationCartesian(0, currentSpeed, currentAngle);
	}

	@Override
	@SuppressWarnings("unused")
	protected boolean isFinished() {
		return (GFORCE_LIMIT < 0 ? (gForce < GFORCE_LIMIT) : (gForce > GFORCE_LIMIT));
	}

	/**
	 * Called once after {@link #isFinished()} returns true.
	 */
	@Override
	protected void end() {
		Robot.driveSubsystem.getMecanumDriveAlgorithm().stop();
	}

	/**
	 * Called when another command which requires one or more of the same
	 * subsystems is scheduled to run.
	 */
	@Override
	protected void interrupted() {
	}
}
