/* 
 * Copyright (c) 2015 RobotsByTheC. All rights reserved.
 *
 * Open Source Software - may be modified and shared by FRC teams. The code must
 * be accompanied by the BSD license file in the root directory of the project.
 */
package org.usfirst.frc.team2084.CMonster2015.commands;

import org.usfirst.frc.team2084.CMonster2015.Robot;
import org.usfirst.frc.team2084.CMonster2015.RobotMap;
import org.usfirst.frc.team2084.CMonster2015.drive.processors.LinearRamper;
import org.usfirst.frc.team2084.CMonster2015.drive.processors.LinearRamper.Type;

import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 * Drives the robot at the specified x and y speeds and heading for a certain
 * amount of time.
 */
public class DriveHeadingCommand extends RotateToCommand {

    public static final double RAMP_RATE = 1.0;

    public static final String X_KEY = "X";
    public static final String Y_KEY = "Y";
    public static final String TIME_KEY = "Time";

    private final LinearRamper xRamper = new LinearRamper(RAMP_RATE, Type.UP);
    private final LinearRamper yRamper = new LinearRamper(RAMP_RATE, Type.UP);

    private double x;
    private double y;

    /**
     * Creates a {@link DriveHeadingCommand} that does nothing for a second.
     * This is mostly here to provide defaults for the parameters.
     */
    public DriveHeadingCommand() {
        this(0.0, 0.0, 0.0, 1.0, 1.0, false);
    }

    /**
     * Drives the robot at the specified x and y speeds and heading for a
     * certain amount of time, while also limiting the max rotation speed.
     * 
     * @param x the x speed
     * @param y the y speed
     * @param heading the heading
     * @param time the amount of time to drive
     */
    public DriveHeadingCommand(double x, double y, double heading, double time, double maxRotationSpeed) {
        this(x, y, heading, time, maxRotationSpeed, false);
    }

    /**
     * Drives the robot at the specified x and y speeds and heading for a
     * certain amount of time, while also limiting the max rotation speed. This
     * can also optionally print out the heading error to the SmartDashboard.
     * 
     * @param x the x speed
     * @param y the y speed
     * @param heading the heading
     * @param time the amount of time to drive
     * @param debug whether to print the heading error
     */
    public DriveHeadingCommand(double x, double y, double heading, double time, double maxRotationSpeed, boolean debug) {
        super(heading, maxRotationSpeed, time, debug);

        addNumberParameter(X_KEY, x);
        addNumberParameter(Y_KEY, y);
        addNumberParameter(TIME_KEY, time);

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveSubsystem);
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    @Override
    protected void initialize() {
        super.initialize();

        x = getNumberParameter(X_KEY);
        y = getNumberParameter(Y_KEY);
        setTimeout(getNumberParameter(TIME_KEY));

        xRamper.reset();
        yRamper.reset();
    }

    @Override
    protected void execute() {
        RobotMap.driveSubsystemMecanumDriveAlgorithm.driveFieldHeadingCartesian(xRamper.process(x), yRamper.process(y),
                heading, rotationRamper.process(maxRotationSpeed));
        if (debug) {
            SmartDashboard.putNumber(HEADING_ERROR_KEY, RobotMap.driveSubsystemMecanumDriveAlgorithm.getHeadingError());
        }
    }

    /**
     * Returns true when the timeout expires.
     */
    @Override
    protected boolean isFinished() {
        return isTimedOut();
    }
}
